{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Seiri","text":"<p>Tool for csv$\\Leftrightarrow$xlsx conversions and validation checks</p>"},{"location":"#installation","title":"Installation","text":"<p>Create a virtual environment before installing dependencies <pre><code>pip install .\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p>This tool is written as library for future adaptation to gui</p> <p>But each class file can be run as a separate script</p>"},{"location":"#transform","title":"Transform","text":"<pre><code>usage: transform.py [-h] [--cx CX] [-o OUTPUT] [--xc XC] [--log LOG] [-v]\n\noptions:\n  -h, --help            show this help message and exit\n  --cx CX               Convert csv to xlsx\n  -o OUTPUT, --output OUTPUT\n                        output file\n  --xc XC               Convert xlsx to csv\n  --log LOG             path to log file\n  -v, --verbose\n</code></pre>"},{"location":"#validate","title":"Validate","text":"<pre><code>usage: validate.py [-h] [--against AGAINST] [--log LOG] in_xlsx\n\npositional arguments:\n  in_xlsx            path to xlsx to validate\n\noptions:\n  -h, --help         show this help message and exit\n  --against AGAINST  path to xlsx to validate against\n  --log LOG          path to log file\n</code></pre>"},{"location":"#example-usage","title":"Example Usage","text":"<p><pre><code>python -m seiri.transform --cx tests/data/Sample.csv -o sample.xlsx --verbose\n</code></pre> </p> <p><pre><code>python -m seiri.validate tests/data/Delivered_correct.xlsx\n</code></pre> <pre><code>python -m seiri.transform --xc tests/data/Delivered_correct.xlsx -o sample.csv  --verbose\n</code></pre> </p>"},{"location":"#testing","title":"Testing","text":"<p>Install the testing dependencies <pre><code>pip install .[test]\n</code></pre></p> <p>Run the following <pre><code>pytest -v\n</code></pre> </p>"},{"location":"#milestones","title":"Milestones","text":"<ul> <li>[$\\checkmark$] Convert csv to xlsx</li> <li>[$\\checkmark$] Validating given Excel with rules</li> <li>[$\\checkmark$] Converting Excel to csv again</li> <li>[$\\checkmark$] Add Spell check on <code>en</code> column</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog.</p> <p>Click here to see the unreleased changes.</p>"},{"location":"changelog/#120-2024-02-29","title":"1.2.0 - 2024-02-29","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Build seiri as a module with hachling and added it to the package (#1)</li> <li>Add coverage badge #2</li> <li>Add mkdocs to the project and deploy it to github pages (#2)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Coverage results are now deployed to codacy instead of github-pages (#1) and can be found here</li> </ul>"},{"location":"changelog/#100-2024-02-26","title":"1.0.0 - 2024-02-26","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Seiri is an automation tool for handling csv&lt;-&gt;xlsx transforms and validating against a specific set of rules</li> <li>It is made to be cross-platform package instead of a script for better adoption to GUI</li> <li>Tests were added under tests/ and it uses <code>pytest</code> which check the package against given csv and xlsx files to check if they are working as intended</li> <li>Coverage results are deployed at every push to static page and can be checked in here</li> </ul>"},{"location":"reference/","title":"Seiri","text":"<p>Seiri package.</p> <p>Seire is an automation tool for csv&lt;-&gt;xlsx conversions and validation checks</p> <p>In this section, you can find how Seiri's components are structured and how they interact with each other.</p> <ul> <li>transform.py \u2013 This contains all transforms (csv &lt;-&gt; xlsx) of <code>seiri</code>.</li> <li>validate.py \u2013 This contains all validation checks as mentioned in the Problem Statement for <code>seiri</code></li> </ul>"},{"location":"reference/transform/","title":"Tranform","text":"<p>This contains base class <code>Transform</code> which holds transforms for csv to xlsx and vice-versa along with spell check as mentioned in the Problem Statement</p>"},{"location":"reference/transform/#seiri.transform.Transform","title":"<code>Transform(verbose=False, log='seiri-error.log')</code>","text":"<p>Transform contains methods for converting:</p> <ol> <li>csv  $\\dashrightarrow$ xlsx</li> <li>xlsx $\\dashrightarrow$ csv</li> </ol> <p>It initializes the following things</p> <ul> <li>Loguru</li> <li>Workbooks</li> <li>Defaults Languages</li> <li>Symspell Dictionary</li> </ul> Source code in <code>seiri/transform.py</code> <pre><code>def __init__(self, verbose: bool = False, log: str = \"seiri-error.log\") -&gt; None:\n    \"\"\"It initializes the following things\n\n    - Loguru\n    - Workbooks\n    - Defaults Languages\n    - Symspell Dictionary\n    \"\"\"\n    \"\"\"\n    Args:\n        verbose (bool): To enable verbose logs\n        log (str): path to log file\n\n    Returns:\n        None\n    \"\"\"\n    # Initialize logger for default logging\n    self.logger = logger\n    self.logger.remove()\n    self.logger.add(\n        sink=log,\n        level=\"ERROR\",\n        format=\"&lt;white&gt;{time:MMMM D, YYYY &gt; HH:mm:ss}&lt;/white&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;level&gt;Transform&lt;/level&gt; | &lt;level&gt;{message}&lt;/level&gt;\",\n    )\n\n    if verbose:\n        self.logger.add(\n            sink=sys.stdout,\n            level=\"DEBUG\",\n            format=\"&lt;white&gt;{time:MMMM D, YYYY &gt; HH:mm:ss}&lt;/white&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;level&gt;Transform&lt;/level&gt; | &lt;level&gt;{message}&lt;/level&gt;\",\n        )\n\n    # Intialize worksheets\n    self.wb = Workbook()\n    self.sheets = []\n    del self.wb[\"Sheet\"]\n\n    # default langs for now\n    self.langs = [\"en\", \"de\", \"es\", \"fr\", \"it\"]\n\n    # Intialize spell checker\n    self.sym_spell = SymSpell(max_dictionary_edit_distance=2, prefix_length=7)\n    dictionary_path = pkg_resources.resource_filename(\n        \"symspellpy\", \"frequency_dictionary_en_82_765.txt\"\n    )\n    bigram_path = pkg_resources.resource_filename(\n        \"symspellpy\", \"frequency_bigramdictionary_en_243_342.txt\"\n    )\n\n    self.sym_spell.load_dictionary(dictionary_path, term_index=0, count_index=1)\n    self.sym_spell.load_bigram_dictionary(bigram_path, term_index=0, count_index=2)\n</code></pre>"},{"location":"reference/transform/#seiri.transform.Transform.__init__sheets","title":"<code>__init__sheets()</code>","text":"<p>Create worksheets from self.lang and appends <code>Key | Value</code> columns</p> Source code in <code>seiri/transform.py</code> <pre><code>def __init__sheets(self) -&gt; None:\n    \"\"\"\n    Create worksheets from self.lang and appends ` Key | Value ` columns\n    \"\"\"\n    for lang in self.langs:\n        self.sheets.append(self.wb.create_sheet(lang))\n        self.logger.info(f\"Created sheet {lang}\")\n\n    for sheet in self.sheets:\n        sheet.append([\"Key\", \"Value\"])\n\n    self.logger.success(\"Successfully initialized Sheets\")\n</code></pre>"},{"location":"reference/transform/#seiri.transform.Transform.csv_to_xlsx","title":"<code>csv_to_xlsx(in_file, out_file)</code>","text":"<p>Converts csv to xlsx and checks for spelling mistakes in the <code>en</code> column</p> <p>Parameters:</p> <ul> <li> <code>in_file</code>             (<code>str</code>)         \u2013          <p>path to input file</p> </li> <li> <code>out_file</code>             (<code>str</code>)         \u2013          <p>path to output file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>seiri/transform.py</code> <pre><code>def csv_to_xlsx(self, in_file: str, out_file: str) -&gt; None:\n    \"\"\"Converts csv to xlsx and checks for spelling mistakes in the `en` column\n\n    Args:\n        in_file (str): path to input file\n        out_file (str): path to output file\n\n    Returns:\n        None\n    \"\"\"\n    Listed_csv = csv.reader(open(in_file, \"r\", newline=\"\"), delimiter=\";\")\n\n    Listed_csv.__next__()\n\n    self.__init__sheets()\n    self.logger.info(\"Spell checking column 'en'\")\n    for row in Listed_csv:\n        if len(row):  # Don't consider empty lines\n            ## Spell check\n            suggestions = self.sym_spell.lookup_compound(\n                row[4], max_edit_distance=2, transfer_casing=True\n            )\n            if suggestions:\n                if suggestions[0].term != row[4]:\n                    self.logger.error(\n                        f\"Spelling mistake found in {row[4]} : Suggestions: {suggestions[0].term}\"\n                    )\n\n            self.sheets[0].append([row[2], row[4]])\n    self.logger.success(\"Spell checked column 'en'\")\n    # Save Workbook\n    self.wb.save(out_file)\n    self.logger.info(f\"Saving workbook to {out_file}\")\n</code></pre>"},{"location":"reference/transform/#seiri.transform.Transform.xlsx_to_csv","title":"<code>xlsx_to_csv(in_file, out_file)</code>","text":"<p>Converts xlsx to csv</p> <p>Parameters:</p> <ul> <li> <code>in_file</code>             (<code>str</code>)         \u2013          <p>path to input file</p> </li> <li> <code>out_file</code>             (<code>str</code>)         \u2013          <p>path to output file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>seiri/transform.py</code> <pre><code>def xlsx_to_csv(self, in_file: str, out_file: str) -&gt; None:\n    \"\"\"Converts xlsx to csv\n\n    Args:\n        in_file (str): path to input file\n        out_file (str): path to output file\n\n    Returns:\n        None\n    \"\"\"\n    # initialize workbook\n    wb = load_workbook(in_file)\n    wb.sheetnames\n    self.logger.success(f\"Loaded {in_file}\")\n\n    # initialize csv writer\n    csv_file = open(out_file, \"w\", newline=\"\")\n    csv_writer = csv.writer(csv_file, delimiter=\";\")\n    self.logger.info(f\"Writing to {out_file}\")\n\n    # write headers \"Section Number;Entry Number;Reference;(default);en;de;es;fr;it;Review \". Some of the headers are from self.langs so iterate over them as well\n    headers = [\"Section Number\", \"Entry Number\", \"Reference\", \"(default)\"]\n    headers.extend(self.langs)\n    headers.append(\"Review\")\n    csv_writer.writerow(headers)\n    self.logger.success(f\"Headers written to {out_file}\")\n\n    # Write rows to csv\n    # each row looks like this\n    # 0;0;lbl_m_access_level;;Access Level;sdfk;ryt;df;g;\n\n    for row in range(2, wb[\"en\"].max_row + 1):\n        row_to_append = [\n            0,\n            0,\n            wb[\"en\"].cell(row=row, column=1).value,\n            \"\",\n        ]\n        for sheet in wb.sheetnames:\n            row_to_append.append(wb[sheet].cell(row=row, column=2).value)\n        row_to_append.append(\"\")\n\n        csv_writer.writerow(row_to_append)\n    self.logger.success(f\"Rows written to {out_file}\")\n\n    # close csv file\n    csv_file.close()\n    self.logger.success(f\"Successfully converted {in_file} to {out_file}\")\n</code></pre>"},{"location":"reference/validate/","title":"Validate","text":""},{"location":"reference/validate/#seiri.validate.Validate","title":"<code>Validate(log='seiri-error.log')</code>","text":"<p>Validate checks given xlsx against given rules</p> <p>Parameters:</p> <ul> <li> <code>log</code>             (<code>str</code>, default:                 <code>'seiri-error.log'</code> )         \u2013          <p>path to log file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul> Source code in <code>seiri/validate.py</code> <pre><code>def __init__(self, log: str = \"seiri-error.log\") -&gt; None:\n    \"\"\"\n    Args:\n        log (str): path to log file\n\n    Returns:\n        None\n    \"\"\"\n    # Initialize logger with default settings\n    self.logger = logger\n    self.logger.remove()\n    self.logger.add(\n        sink=log,\n        level=\"ERROR\",\n        format=\"&lt;white&gt;{time:MMMM D, YYYY &gt; HH:mm:ss}&lt;/white&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;level&gt;Validate&lt;/level&gt; | &lt;level&gt;{message}&lt;/level&gt;\",\n    )\n    self.logger.add(\n        sink=sys.stdout,\n        format=\"&lt;white&gt;{time:MMMM D, YYYY &gt; HH:mm:ss}&lt;/white&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;level&gt;Validate&lt;/level&gt; |  &lt;level&gt;{message}&lt;/level&gt;\",\n    )\n</code></pre>"},{"location":"reference/validate/#seiri.validate.Validate.validate","title":"<code>validate(in_xlsx, against_xlsx)</code>","text":"The following checks are performed <ol> <li> <p>Check if both excel book:</p> <p>a. row count is same in the en sheet</p> <p>b. key and value order is same</p> </li> <li> <p>Check if all sheets in the in_xlsx have same row count</p> </li> <li>The \u201cen\u201d sheet key should be available and match in all other sheets</li> <li>The \u201cen\u201d sheet key order should atch in all other sheets</li> <li>The value text in all other sheets should not be empty</li> <li>The text in value column in all sheets should be unique</li> <li>Check if the string length of value column in all sheets is less than the string length if value column in en sheet</li> </ol> <p>Parameters:</p> <ul> <li> <code>in_xlsx</code>             (<code>str</code>)         \u2013          <p>path to xlsx to validate</p> </li> <li> <code>against_xlsx</code>             (<code>str</code>)         \u2013          <p>path to xlsx to validate against</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (            <code>bool</code> )        \u2013          <p>True if all guards pass</p> </li> </ul> Source code in <code>seiri/validate.py</code> <pre><code>def validate(self, in_xlsx: str, against_xlsx: str) -&gt; bool:\n    \"\"\"The following checks are performed:\n        1. Check if both excel book:\n\n            a. row count is same in the en sheet\n\n            b. key and value order is same\n\n        2. Check if all sheets in the in_xlsx have same row count\n        3. The \u201cen\u201d sheet key should be available and match in all other sheets\n        4. The \u201cen\u201d sheet key order should atch in all other sheets\n        5. The value text in all other sheets should not be empty\n        6. The text in value column in all sheets should be unique\n        7. Check if the string length of value column in all sheets is less than the string length if value column in en sheet\n\n    Args:\n        in_xlsx (str): path to xlsx to validate\n        against_xlsx (str): path to xlsx to validate against\n\n    Returns:\n        bool: True if all guards pass\n    \"\"\"\n    # Return True if all guards pass\n    ret = True\n\n    if not os.path.exists(in_xlsx):\n        self.logger.error(f\"Could not find {in_xlsx}\")\n        ret = False\n\n    if not os.path.exists(against_xlsx):\n        self.logger.error(f\"Could not find {against_xlsx}\")\n        ret = False\n\n    self.logger.success(f\"Found {in_xlsx} and {against_xlsx}\")\n    self.logger.info(f\"Validating {in_xlsx} against {against_xlsx}\")\n\n    in_wb = openpyxl.load_workbook(in_xlsx)\n    self.logger.success(f\"Loaded {in_xlsx}\")\n\n    against_wb = openpyxl.load_workbook(against_xlsx)\n    self.logger.success(f\"Loaded {against_xlsx}\")\n\n    # 1. Check if both excel book row count is same in the en sheet\n    self.logger.info(f\"Checking row count against {against_xlsx} in en sheet\")\n    if in_wb[\"en\"].max_row != against_wb[\"en\"].max_row:\n        self.logger.error(\"Row count mismatch in en sheet\")\n        ret = False\n    else:\n        self.logger.success(\"Row count match in en sheet\")\n\n    # 1. Check if key and value order is same in the en sheet for both excel sheet \"en\"\n    self.logger.info(\n        f\"Checking key and value order against {against_xlsx} in en sheet\"\n    )\n    for row in range(1, in_wb[\"en\"].max_row + 1):\n        if (\n            in_wb[\"en\"].cell(row=row, column=1).value\n            != against_wb[\"en\"].cell(row=row, column=1).value\n        ):\n            self.logger.error(\n                f\"Key mismatch in en sheet at row {row}. Expected: {against_wb['en'].cell(row=row, column=1).value}, Actual: {in_wb['en'].cell(row=row, column=1).value}\"\n            )\n            ret = False\n        if (\n            in_wb[\"en\"].cell(row=row, column=2).value\n            != against_wb[\"en\"].cell(row=row, column=2).value\n        ):\n            self.logger.error(\n                f\"Value mismatch in en sheet at row {row}. Expected: {against_wb['en'].cell(row=row, column=2).value}, Actual: {in_wb['en'].cell(row=row, column=2).value}\"\n            )\n            ret = False\n\n    self.logger.success(\"Key and Value order match in en sheet\")\n    self.logger.success(f\"Validation successful against {against_xlsx}\")\n\n    # Now onto checks only in the in_xlsx\n    # 2. Check if all sheets in the in_xlsx have same row count\n    self.logger.info(\"Checking row count in all sheets\")\n    for sheet in in_wb.sheetnames:\n        if in_wb[sheet].max_row != in_wb[\"en\"].max_row:\n            self.logger.error(f\"Row count mismatch in {sheet} sheet\")\n            ret = False\n        else:\n            self.logger.success(f\"Row count match in {sheet} sheet\")\n\n    # 3,4. The \u201cen\u201d sheet key should be available and match in all other sheets\n    self.logger.info(\"Checking if 'en' key is available in all sheets\")\n    for row in range(1, in_wb[\"en\"].max_row + 1):\n        key = in_wb[\"en\"].cell(row=row, column=1).value\n        # Check if this key is in all other sheets\n        for sheet in in_wb.sheetnames:\n            if sheet == \"en\":\n                continue\n\n            # handle when cell is empty\n            if in_wb[sheet].cell(row=row, column=1).value is None:\n                self.logger.error(f\"Empty cell in {sheet} sheet at row {row}\")\n                continue\n\n            if key not in in_wb[sheet].cell(row=row, column=1).value:\n                self.logger.error(\n                    f\"Mismatched value in {sheet} sheet at row {row}. Expected: {key}, Actual: {in_wb[sheet].cell(row=row, column=1).value}\"\n                )\n                ret = False\n    self.logger.success(\n        \"Key found in all sheets and the order is same across all sheets\"\n    )\n\n    # 5. Check if the value text in all other sheets should not be empty\n    self.logger.info(\"Checking if value is not empty in all sheets\")\n    for sheet in in_wb.sheetnames:\n        if sheet == \"en\":\n            continue\n        for row in range(1, in_wb[sheet].max_row + 1):\n            if in_wb[sheet].cell(row=row, column=2).value == \"\":\n                self.logger.error(\n                    f\"Empty value found in {sheet} sheet at row {row}\"\n                )\n                ret = False\n    self.logger.success(\"Value Column is not empty in all sheets - 'en'\")\n\n    # 6. Check if the text in value column in all sheets is unique\n    self.logger.info(\"Checking if value is unique in all sheets\")\n    for sheet in in_wb.sheetnames:\n        unique_values = set()\n        for row in range(1, in_wb[sheet].max_row + 1):\n            value = in_wb[sheet].cell(row=row, column=2).value\n            if value in unique_values:\n                self.logger.error(\n                    f\"Duplicate value '{value}' found in {sheet} sheet\"\n                )\n                ret = False\n            unique_values.add(value)\n    self.logger.success(\"Value Column is unique in all sheets\")\n\n    # 8. Check if the string length of value column in all sheets is less than the string length if value column in en sheet\n    self.logger.info(\"Checking if value is less than en value in all sheets\")\n    for sheet in in_wb.sheetnames:\n        if sheet == \"en\":\n            continue\n        for row in range(1, in_wb[sheet].max_row + 1):\n            # When the cell is empty\n            if in_wb[sheet].cell(row=row, column=2).value is None:\n                continue\n\n            if len(in_wb[sheet].cell(row=row, column=2).value) &gt; len(\n                in_wb[\"en\"].cell(row=row, column=2).value\n            ):\n                value = in_wb[sheet].cell(row=row, column=2).value\n                en_value = in_wb[\"en\"].cell(row=row, column=2).value\n                self.logger.error(\n                    f\"Length({value})={len(value)} in '{sheet}' sheet at row {row} is greater than length({en_value})={len(en_value)} in 'en' sheet\"\n                )\n                ret = False\n    self.logger.success(\"Value Column is less than en value in all sheets\")\n\n    self.logger.success(f\"Validation successful for {in_xlsx}\")\n\n    return ret\n</code></pre>"}]}